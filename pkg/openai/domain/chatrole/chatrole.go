package chatrole

import (
	"fmt"
	"sort"
	"strings"
)

// ChatRole defines a role in a chat conversation.
type ChatRole struct {
	Code        string // Unique identifier for the chat role.
	Description string // Human-readable explanation of the chat role.
}

// Chat role code constants.
const (
	SystemCode    = "system"
	UserCode      = "user"
	AssistantCode = "assistant"
	ToolCode      = "tool"
)

// Predefined ChatRole instances.
var (
	System = &ChatRole{
		Code:        SystemCode,
		Description: "System-level instructions that guide the assistant's behavior.",
	}
	User = &ChatRole{
		Code:        UserCode,
		Description: "Represents user-provided input in the conversation.",
	}
	Assistant = &ChatRole{
		Code:        AssistantCode,
		Description: "Represents responses generated by the assistant model.",
	}
	Tool = &ChatRole{
		Code:        ToolCode,
		Description: "Represents output from a tool or function call.",
	}
)

// AllChatRoles maps all known chat role codes to their ChatRole instances.
var AllChatRoles = map[string]*ChatRole{
	SystemCode:    System,
	UserCode:      User,
	AssistantCode: Assistant,
	ToolCode:      Tool,
}

// Resolve returns the ChatRole associated with the given code.
// Returns an error if the code is empty or unrecognized.
func Resolve(code string) (*ChatRole, error) {
	if code == "" {
		return nil, fmt.Errorf("chat role code is required")
	}
	if chr, ok := AllChatRoles[code]; ok {
		return chr, nil
	}
	return nil, fmt.Errorf("unknown chat role code: '%s'", code)
}

// JoinCodes returns a sorted, delimited string of all known chat role codes.
func JoinCodes(sep string) string {
	codes := make([]string, 0, len(AllChatRoles))
	for code := range AllChatRoles {
		codes = append(codes, code)
	}
	sort.Strings(codes)
	return strings.Join(codes, sep)
}
